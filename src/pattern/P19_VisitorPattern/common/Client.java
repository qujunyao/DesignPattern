package pattern.P19_VisitorPattern.common;

/**
 * 访问者模式 ：场景类
 * 
 * 定义：
 * 封装一些作用于某种数据结构中的各个元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新操作。
 * 
 * 角色：
 * 1、Visitor抽象访问者
 * 抽象类或者接口声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以访问的。
 * 2、ConcreteVisitor具体访问者
 * 他影响访问者访问到一个类后该怎么干，要做什么事情。
 * 3、Element抽象元素
 * 接口或者抽像类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数定义的。
 * 4、ConcreteElement具体元素
 * 实现accept方法，通常是visitor.visit(this),基本上都形成了一种模式了。
 * 5、ObjectStruture结构对象
 * 元素生产者，一般容纳在多个不同类、不同接口的容器中，如list,map,set等，在项目中，一般很少抽象出这个角色。
 * 
 * 优点：
 * 1、符合单一职责原则
 * 具体元素角色也就是Element抽象类的两个子类负责数据的加载，而Visitor类则负责报表的展现，两个不同的职责非
 * 常明确的分离开来，各自演绎变化。
 * 2、优秀的扩展性
 * 由于职责分开，继续增加对数据的操作是非常快捷的。
 * 3、灵活性非常高
 * 
 * 
 * 缺点：
 * 1、具体元素对访问者提供细节
 * 访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是说访问者关注了其他类的内部细节，这是迪米特发则不建议的。
 * 2、具体元素变更比较困难
 * 具体元素角色的增加，删除，修改是比较困难的。
 * 3、违背了依赖倒置原则
 * 访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置的原则，特别是在面向对象编程中，抛弃了对接口的依赖，而直接
 * 依赖实现类，扩展比较困难。
 * 
 * 
 * 适用场景：
 * 1、一个对象结构包含很多类的对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就是说用迭代器模
 * 式已经不能胜任的情景。
 * 2、需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。
 * 
 * @author Administrator
 *
 */
public class Client {

	public static void main(String[] args) {
		for (int i = 0; i < 10; i++) {
			// 获得对象元素
			Element e = ObjectStruture.createElement();
			// 接受访问者访问
			e.accept(new Visitor());
		}
	}
}
