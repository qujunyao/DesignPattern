package pattern.P20_StatePattern;

/**
 * 状态模式：场景类
 * 
 * 定义：
 * 当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。状态模式的核心是封装，状态的变更引起了行为的变更，
 * 从外部看起来就好像这个对象对应的类发生了改变一样
 * 
 * 角色：
 * 1、State抽象状态角色
 * 接口或者抽象类，负责对对象状态的定义，并且封装环境角色以实现状态切换。
 * 2、ConcreteState具体状态角色
 * 每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理，通俗的说，就是本状态下要做的事情，以及本状态如何过度
 * 到其他状态。
 * 3、Context环境角色
 * 定义客户端需要的接口，并负责具体状态的切换。
 *
 * 优点：
 * 1、结构清晰
 * 避免了过多的switch...case或者if...else语句的使用，避免了程序的复杂性，提高系统的可维护性。
 * 2、遵循设计原则
 * 很好的体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，只修改子类就可以。
 * 3、封装性非常好
 * 这也是状态模式的基本要求，状态变换放置到内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。
 *
 * 缺点：
 * 子类过多，容易类膨胀。
 * 
 * 适用场景：
 * 1、行为随状态改变而改变的场景
 * 这也是状态模式的根本出发点，例如权限设计，人员的状态不同即时使用相同的行为结果也会不同，在这种状态下需要考虑使用状态模式。
 * 2、条件、分支判断语句的替代者
 * 在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑结构混乱，使用状态模式可以很好的避免这一问题，他通
 * 过扩展子类实现了条件的判断处理。
 * 
 * 注意事项：
 * 状态模式适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的的情况下可以使用
 * 状态模式，而且使用时对象的状态最好不要超过5个。
 * 
 * 
 * 
 * @author Administrator
 *
 */
public class Client {

	public static void main(String[] args) {
		// 定义环境角色
		Context context = new Context();
		// 初始化状态
		context.setCurrentState(new ConcreteState1());
		// 执行行为
		context.handle1();
		context.handle2();

	}
}
