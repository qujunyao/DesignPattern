package pattern.P22_FlyweightPattern;

/**
 * 享元模式：场景类
 * 
 * 定义：
 * 使用共享对可有效的支持大量的细粒度的对象。
 * 享元模式定义为我们提出了两个要求：细粒度的对象和共享对象。这些对象的信息分为两个部分：内部状态和外部状态。
 * 
 * 内部状态：
 * 内部转态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变，它们可以作为一个对象的动态附加信息，
 * 不必直接存储在具体某个对象中，属于可以共享的部分。
 * 
 * 外部状态：
 * 外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态，它是一批对象的标识，是唯一的一个索引值。
 * 
 * 角色：
 * 1、Flyweight抽象享元角色
 * 它简单的说就是一个产品的抽像类，同时定义出对象的外部状态和内部状态的接口或实现。
 * 2、ConcreteFlyweight具体享元角色
 * 具体的一个产品类，实现抽象角色定义的业务，该角色中需要注意的是内部状态处理应该和环境无关，不应该出现一个操作改变了
 * 内部状态，同时修改了外部状态，这是绝对不允许的。
 * 3、unshareConcreteFlyweight不可共享的享元角色
 * 不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象。
 * 4、FlyweightFactory享元工厂
 * 职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。
 * 
 * 优点：
 * 享元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能。
 * 
 * 缺点：
 * 提高了程序的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统
 * 逻辑混乱。
 * 
 * 使用场景：
 * 1、系统中存在大量的相似的对象。
 * 2、细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定的身份。
 * 3、需要缓冲池的场景。
 * 
 * 注意事项：
 * 虽然可以使用享元模式可以实现对象池，但是这两者还是有比较大的差异，对象池着重在对象的复用上，池中的每个对象是可以替换的
 * 从同一个池中获取A对象和B对象对客户端来说是完全相同的，它主要解决复用，而享元模式在主要解决的对象的共享问题，如何建立多
 * 个可共享的细粒度对象则是其关注的重点。
 * 
 * @author Administrator
 *
 */
public class Client {

	public static void main(String[] args) {
		//初始化池中数据
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 10; j++) {
				String key = "第" + i + "行，第" + j + "列";
				FlyweightFactory.getFlyweight(key);
			}
		}
		//从池中取数据
		@SuppressWarnings("unused")
		Flyweight concreteFlyweight1 = FlyweightFactory.getFlyweight("第2行，第3列");
	}
}
