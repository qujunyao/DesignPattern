package pattern.P23_BridgePattern;

/**
 * 桥梁模式：场景类
 * 
 * 定义：
 * 也叫做桥接模式，将抽象和实现解耦，使得两者可以独立的变化。
 * 
 * 角色：
 * 1、Abstraction抽象化角色
 * 它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。
 * 2、Implementor实现化角色
 * 它是接口或者抽象类，定义角色必须的行为和属性。
 * 3、ConcreteImplementor具体实现化角色
 * 它实现接口或抽象类定义的方法和属性。
 * 
 * 优点：
 * 1、抽象和现实分离
 * 也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式，在该模式下，实现可
 * 以不受抽象的约束，不用再绑定在一个固定的抽象层次上。
 * 2、优秀的扩展能力
 * 3、实现细节对客户透明
 * 客户不用关心细节的实现， 它已经由抽象层通过聚合关系完成了封装。
 * 
 * 使用场景：
 * 1、不希望或不适用使用的场景
 * 例如继承层次过度，无法更细化设计颗粒等场景，需要考虑使用桥梁模式。
 * 2、接口或者抽象类不稳定的场景
 * 明知道接口不稳定还想通过实现或继承来实现业务需求，那就是得不偿失，也是比较失败的做法。
 * 3、重用性要求较高的场景
 * 设计的颗粒度越细，则重用的可能性就越大，而采用继承则受父类的限制，不可能出现太细的颗粒度。
 * 
 * 注意事项：
 * 桥梁模式是非常简单的，使用该模式时主要考虑如何拆分抽象和实现，并不是一涉及继承就要考虑使用
 * 该模式，桥梁模式的意图还是对变化的封装，尽量将可能变化的因素封装到最细、最小的逻辑单元中，
 * 避免风险扩散，因此在进行系统设计时，发现类继承有N层时，可以考虑使用桥梁模式。
 * 
 *	 
 * @author Administrator
 *
 */
public class CLient {

	public static void main(String[] args) {
		// 定义一个实现化角色
		Implementor implementor = new ConcreteImplementor1();

		// 定义一个抽象化角色
		Abstraction abstraction = new RefinedAbstraction(implementor);

		// 执行流程
		abstraction.request();
	}
}
