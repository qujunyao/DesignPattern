package pattern.p16_ObserverPattern;

/**
 * 观察者模式：场景类
 * 
 * 定义：
 * 观察者模式也叫做发布订阅模式，他是一个在项目中经常使用的模式，定义如下，
 * 定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。
 * 
 * 角色模块：
 * 1、Subject被观察者
 * 定义被观察者必须实现的职责，它必须能够动态的增加，删除观察者，它一般是抽象类或者是实现类，仅仅完成作为
 * 被观察者必选实现的职责：管理观察者并通知观察者。
 * 2、Observer观察者
 * 观察者接受到消息后，进行update（更新）操作，对接受到的信息进行处理。
 * 3、ConcreteSubject具体的被观察者
 * 定义被观察者自己的业务逻辑，同时定义对那些事件的通知。
 * 4、ConcreteObserver具体的观察者
 * 每个观察者在接受到消息后的处理反应是不同的，各个观察者有自己的处理逻辑。
 * 
 * 优点：
 * 1、观察者和被观察者之间是抽象耦合
 * 如此设计，则不管是增加观察者，还是被观察者都非常容易扩展，而且在java中都已经实现的抽象层级定义，在系统
 * 扩展方面都得心应手。
 * 2、建立一套触发机制
 * 根据单一职责原则，每个类的职责是单一的，比如，猎人打猎，死了一只母鹿，母鹿有三个幼崽，因没有母鹿在照顾而
 * 饿死，尸体被两只秃鹰争夺，因分配不均开始斗殴，然后输了的秃鹰死掉，生存下来的因此扩大了地盘，这就形成了一
 * 个触发机制，形成了一个触发链，观察者 模式可以完美的实现这里的链条形式。
 * 
 *  
 * 缺点：
 * 需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，在开发和调试的时候就比较复杂，而且在java中
 * 消息的通知默认是顺序执行的，一个观察者卡壳会影响整体的执行效率，这种情况下，一般考虑使用异步的方式。
 * 
 * 
 * 适用场景：
 * 1、关联行为场景。需要注意的是，关联行为是可拆分的，而不是组合的关系。
 * 2、事件多级触发场景。
 * 3、跨系统的消息交换场景，如消息队列的处理机制。
 * 
 * 注意事项：
 * 1、广播链的问题。
 * 2、异步处理问题。
 * 
 * @author Administrator
 *
 */
public class Client {

	public static void main(String[] args) {
		// 创建一个被观察者
		ConcreteSubject subject = new ConcreteSubject();
		// 创建一个观察者
		Observer observer = new ConcreteObserver();
		// 观察者观察被观察者
		subject.addObserver(observer);
		// 观察者开始行动了
		subject.doSomething();
	}
}
